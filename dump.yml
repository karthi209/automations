#!/bin/bash

# Ensure both tags are provided
if [ "$#" -ne 2 ]; then
    echo "Usage: $0 <old_tag> <new_tag>"
    exit 1
fi

OLD_TAG=$1
NEW_TAG=$2
GITHUB_URL="https://github.com/YOUR_ORG/YOUR_REPO"

echo "Generating changelog links for submodules between $OLD_TAG and $NEW_TAG..."

# Get commit messages in the main repository
echo -e "\n### Main Repository Changes ###"
echo "$GITHUB_URL/compare/$OLD_TAG...$NEW_TAG"

# Loop through submodules and generate links
while read -r SUBMODULE_PATH; do
    echo -e "\n#### Submodule: $SUBMODULE_PATH ####"

    # Get the commit hash of the submodule from the main repository at OLD_TAG
    OLD_COMMIT=$(git ls-tree "$OLD_TAG" -- "$SUBMODULE_PATH" 2>/dev/null | awk '{print $3}')

    # Debugging output
    echo "DEBUG: OLD_COMMIT for $SUBMODULE_PATH: $OLD_COMMIT"

    if [ -z "$OLD_COMMIT" ]; then
        echo "⚠️ Skipping $SUBMODULE_PATH: Not present in $OLD_TAG"
    else
        # Ensure commit exists in the local repo
        if ! git rev-parse "$OLD_COMMIT" >/dev/null 2>&1; then
            echo "⚠️ OLD_COMMIT ($OLD_COMMIT) not found locally. Try 'git fetch --recurse-submodules'."
        else
            # Get the latest commit in the submodule
            NEW_COMMIT=$(git rev-parse HEAD:"$SUBMODULE_PATH")
            SUBMODULE_URL="'"$GITHUB_URL"'/$SUBMODULE_PATH"
            echo "$SUBMODULE_URL/compare/$OLD_COMMIT...$NEW_COMMIT"
        fi
    fi
done < <(git config --file .gitmodules --get-regexp path | awk '{print $2}')
