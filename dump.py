import subprocess
import pytest

def get_python_version():
    result = subprocess.run(["python3", "--version"], capture_output=True, text=True)
    return result.stdout.strip()

@pytest.fixture(scope="module")
def python_version():
    version = get_python_version()
    return version

def test_python_version(python_version):
    assert python_version.startswith("Python 3"), f"Expected Python 3, got {python_version}"

# Add version information to the pytest metadata
def pytest_collection_modifyitems(config, items):
    for item in items:
        item.add_marker(pytest.mark.version(get_python_version()))

def test_python_functionality():
    # Your other Python-related tests
    assert True  # This can be replaced with real functionality tests




import json

def generate_markdown_summary(json_report_path):
    # Read the JSON report generated by pytest
    with open(json_report_path, 'r') as file:
        report = json.load(file)
    
    # Initialize the markdown content
    markdown_content = "# Test Report Summary\n\n"
    markdown_content += "| Tool Name | Version | Test Results | Health |\n"
    markdown_content += "|-----------|---------|--------------|--------|\n"

    # Iterate over each test result in the report
    for entry in report.get('tests', []):
        tool_name = entry.get('name', 'Unknown Tool')
        
        # Extract version from the markers
        version = next((mark.args[0] for mark in entry.get('marks', []) if mark.name == 'version'), 'Version not found')

        total_tests = len(entry.get('tests', []))
        passed_tests = sum(1 for test in entry.get('tests', []) if test.get('outcome') == 'passed')
        
        # Calculate the health (green check for full pass, red cross for failure)
        health = ":green_check:" if passed_tests == total_tests else ":x:"
        
        # Generate a row for each tool
        markdown_content += f"| {tool_name} | {version} | {passed_tests}/{total_tests} tests passed | {health} |\n"
    
    return markdown_content

if __name__ == "__main__":
    json_report_path = "./test_report.json"  # Path to the JSON report
    markdown_summary = generate_markdown_summary(json_report_path)
    
    # Print or write the markdown content to a file
    print(markdown_summary)
    with open("test_report_summary.md", "w") as md_file:
        md_file.write(markdown_summary)






import subprocess
import pytest

def get_maven_version():
    result = subprocess.run(["mvn", "-v"], capture_output=True, text=True)
    version_line = result.stdout.splitlines()[0]
    return version_line.split()[2]  # Extracting the version from the first line of output

@pytest.fixture(scope="module")
def maven_version():
    version = get_maven_version()
    return version

def test_maven_version(maven_version):
    assert maven_version.startswith("3"), f"Expected Maven 3, got {maven_version}"

# Add version information to the pytest metadata
def pytest_collection_modifyitems(config, items):
    for item in items:
        item.add_marker(pytest.mark.version(get_maven_version()))

def test_maven_functionality():
    # Your other Maven-related tests (if applicable)
    assert True  # Replace with actual functionality tests if necessary





import subprocess
import pytest

def get_git_version():
    result = subprocess.run(["git", "--version"], capture_output=True, text=True)
    version_line = result.stdout.strip()
    return version_line.split()[2]  # Extracting the version from the first line of output

@pytest.fixture(scope="module")
def git_version():
    version = get_git_version()
    return version

def test_git_version(git_version):
    assert git_version.startswith("2"), f"Expected Git 2.x, got {git_version}"

# Add version information to the pytest metadata
def pytest_collection_modifyitems(config, items):
    for item in items:
        item.add_marker(pytest.mark.version(get_git_version()))

def test_git_functionality():
    # Your other Git-related tests (if applicable)
    assert True  # Replace with actual functionality tests if necessary
